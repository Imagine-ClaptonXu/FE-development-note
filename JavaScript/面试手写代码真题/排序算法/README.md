# 常见排序算法的 JavaScript 实现
> 1. 冒泡排序 (Bubble Sort)
> 2. 选择排序 (Selection Sort)
> 3. 插入排序 (Insertion Sort)
> 4. 希尔排序 (Shell Sort)
> 5. 快速排序 (Quick Sort) 递归 & 堆栈
> 6. 归并排序 (Merge sort)
> 7. 计数排序 (Counting Sort)
> 8. 桶排序 (Bucket Sort)
> 9. 基数排序 (Radix Sort)
> 10. 堆排序 (Heap Sort)

### 冒泡排序 (Bubble Sort)
> 是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。
- 时间复杂度(平均): O(n²)
- 时间复杂度(最坏): O(n²)
- 时间复杂度(最好): O(n)
- 空间复杂度: O(1)
- 排序方式: In-place
- 稳定性: 稳定

### 选择排序 (Selection Sort)
> 找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推
- 时间复杂度(平均): O(n²)
- 时间复杂度(最坏): O(n²)
- 时间复杂度(最好): O(n²)
- 空间复杂度: O(1)
- 排序方式: In-place
- 稳定性: 不稳定

### 插入排序 (Insertion Sort)
> 是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
- 时间复杂度(平均): O(n²)
- 时间复杂度(最坏): O(n²)
- 时间复杂度(最好): O(n)
- 空间复杂度: O(1)
- 排序方式: In-place
- 稳定性: 稳定

### 希尔排序 (Shell Sort)
> 也称递减增量排序算法，是插入排序的一种高效改进版本，它与插入排序的不同之处在于，它会优先比较距离较远的元素。
- 时间复杂度(平均): O(n^1.3)
- 时间复杂度(最坏): O(n²)
- 时间复杂度(最好): O(n)
- 空间复杂度: O(1)
- 排序方式: In-place
- 稳定性: 不稳定

### 快速排序 (Quick Sort) (递归 & 堆栈)
> 是通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。
- 时间复杂度(平均): O(nlogn)
- 时间复杂度(最坏): O(n²)
- 时间复杂度(最好): O(nlogn)
- 空间复杂度: O(nlogn)
- 排序方式: In-place
- 稳定性: 不稳定

### 归并排序 (Merge sort)
> 是建立在归并操作上的一种有效的排序算法。该算法是采用分治法(Divide and Conquer)。将有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段有序。其思想是将原始数组切分成较小的数组，直到每个较小数组只有一个元素，接着将小数组归并成较大的数组，到最后只有一个排序完毕的大数组。
- 时间复杂度(平均): O(nlogn)
- 时间复杂度(最坏): O(nlogn)
- 时间复杂度(最好): O(nlogn)
- 空间复杂度: O(n)
- 排序方式: Out-place
- 稳定性: 稳定

### 计数排序 (Counting Sort)
> 不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。
- 时间复杂度(平均): O(n+k)
- 时间复杂度(最坏): O(n+k)
- 时间复杂度(最好): O(n+k)
- 空间复杂度: O(n+k)
- 排序方式: Out-place
- 稳定性: 稳定

### 桶排序 (Bucket Sort)
> 是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理: 假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序(有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排)。
- 时间复杂度(平均): O(n+k)
- 时间复杂度(最坏): O(n²)
- 时间复杂度(最好): O(n+k)
- 空间复杂度: O(n+k)
- 排序方式: Out-place
- 稳定性: 稳定

### 基数排序 (Radix Sort)
> 是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。
- 时间复杂度(平均): O(n*k)
- 时间复杂度(最坏): O(n*k)
- 时间复杂度(最好): O(n*k)
- 空间复杂度: O(n+k)
- 排序方式: Out-place
- 稳定性: 稳定

### 堆排序 (Heap Sort)
> 是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质: 即子结点的键值或索引总是小于(或者大于)它的父节点。
- 时间复杂度(平均): O(nlogn)
- 时间复杂度(最坏): O(nlogn)
- 时间复杂度(最好): O(nlogn)
- 空间复杂度: O(1)
- 排序方式: In-place
- 稳定性: 不稳定

##### Reference
[掘金 - 十大排序算法合集超详细](https://juejin.cn/post/6860273835074617358?searchId=202406251442382C737C812A9F69B33CD6#heading-47)

[掘金 - 实现十大排序算法（图文详解）](https://juejin.cn/post/7099436855388536869)

[github - twobinSort](https://github.com/twobin/twobinSort)
